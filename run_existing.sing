//
system("--min-time", "0.001");
system("--ticks-per-sec", 1000);
option(noredefine);
option(redSB);
LIB "benchs.lib";

string NL = "
";
proc test_kgb(string bench_call, string gb_call)
{
	string uniq_name = bench_call+"_by_"+gb_call;
	sprintf("--- "+uniq_name+"---");
	execute(bench_call)
	int ot0 = timer;
	execute("ideal f =" + gb_call);
	int ot1 = timer;
	ideal f_reduced = interred(f);
	int ot2 = timer;
	string info = 
		sprintf("Size of reduced basis:    %s    non-reduced:%s",size(f_reduced),size(f)) + NL +
		sprintf("Time:                     %s    %s", ot1-ot0, ot2-ot1);
	printf(info);
	link save = "ASCII:w res/" + uniq_name;
	write(save,f_reduced);
	printf("saved");
}

newstruct("lp","poly s, poly p");
newstruct("lpmul","lp","poly smuled");
proc gvw_less(lp p1, lp p2)
{
	poly l1 = leadmonom(p1.p)*p2.s;
	poly l2 = leadmonom(p2.p)*p1.s;
	return (l1<l2);
}
proc smul_less(lpmul p1, lpmul p2)
{
	poly l1 = p1.smuled;
	poly l2 = p2.smuled;
	return (l1<l2);
}

proc insert_in_sorted_list_with_pos(list sorted_list, def new_elem, string comp_func, int min_pos, int max_pos)
{
	string exec_str = "int compare_result="+comp_func+"(new_elem, sorted_list[pos+1])";
	int pos = -1;
	while (min_pos < max_pos - 1)
	{
		pos = (min_pos + max_pos) div 2;
		execute(exec_str);
		if (compare_result) {max_pos = pos;}
		else {min_pos = pos;}
	}
	pos = min_pos;
	while (pos < size(sorted_list))
	{
		execute(exec_str);
		if (compare_result) {break;}
		pos++;
	}
	return(insert(sorted_list, new_elem, pos), pos+1);
}
proc insert_in_sorted_list(list sorted_list, def new_elem, string comp_func)
{
	list result;
	int pos_unused;
	result, pos_unused = insert_in_sorted_list_with_pos(sorted_list, new_elem, comp_func, 0, size(sorted_list));
	return(result);
}

proc ssg_sing(ideal I)
{
	proc create_lp(poly s, poly p)
	{
		lp result;
		result.s = s;
		result.p = p;
		return(result);
	}
	proc create_lpmul(poly mul_by, lp sp)
	{
		lpmul result;
		result.smuled = sp.s*mul_by;
		result.s = sp.s;
		result.p = sp.p;
		return(result);
	}
	proc norm_leadcoef(poly p)
	{
		return(simplify(p,1));
	}
	proc check_b_elem_full(lpmul b_elem, lp r_elem)
	{
		if (gvw_less(r_elem,b_elem) == 0) {return (0)};
		return (b_elem.smuled/r_elem.s != 0);
	}
	int zero_reductions = 0;
	ideal I0 = I[1];
	for (int n = 2; n <= size(I); n++)
	{
		I0 = interred(I0);
		lp p = create_lp(1,I[n]);
		list R;
		list B;
		for (int n0 = 1; n0 <= size(I0); n0++)
		{
			R = list(create_lp(leadmonom(I0[n0]), 0)) + R + list(create_lp(0,norm_leadcoef(I0[n0])));
		}
		while(1)
		{
			int reduced_to_zero = 0;
			int min_used_reductor = size(R);
			while(1)
			{
				lp reductor;
				poly plead = leadmonom(p.p);
				poly div_result = 0;
				for (int n0 = size(R); n0 >=1 ; n0--)
				{
					lp rn = R[n0];
					if (n0 < min_used_reductor){if (gvw_less(p,rn) == 0) {break;}}
					div_result = plead/leadmonom(rn.p);
					if (div_result!=0)
					{
						reductor = rn;
						min_used_reductor = n0;
						break;
					}
				}	 	
				if (reductor.p == 0) {break;}
				p.p = norm_leadcoef(p.p-div_result*reductor.p);
				if (p.p == 0)
				{
					reduced_to_zero = 1;
					zero_reductions++;
					break;
				}
			}
			int insert_position = -1;
			R,insert_position = insert_in_sorted_list_with_pos(R, p, "gvw_less", 0, min_used_reductor);
			int nb = 1;
			while (nb <= size(B))
			{
				lpmul b = B[nb];
				if (check_b_elem_full(b, p))
				{
					B = delete(B, nb);						
				}
				else
				{
					nb++;
				}
			}
			if (reduced_to_zero == 0)
			{
				poly plead = leadmonom(p.p);
				for (int n0 = size(R); n0 > insert_position; n0--)
				{
					lp rn = R[n0];					
					if (gvw_less(p,rn) == 0) {break;}
					poly l2 = leadmonom(rn.p);
					lpmul b_new = create_lpmul(l2/gcd(l2,plead),p);
					for (int nr_2 = 1; nr_2 < insert_position; nr_2++)
					{
						lp rn2 = R[nr_2];
						if (b_new.smuled/rn2.s == 0)
						{
							nr_2++;
							continue;
						}
						if (gvw_less(rn2,b_new) != 0)
						{
							b_new.smuled = poly(0);
							break;
						}
					}
					if (b_new.smuled != 0)
					{
						B = insert_in_sorted_list(B, b_new, "smul_less");
					}
				}
				for (int n0 = 1; n0 < insert_position; n0++)
				{
					lp rn = R[n0];
					if (gvw_less(rn,p) == 0) {break;}
					if (rn.p == 0) {n0++; continue;}
					poly l2 = leadmonom(rn.p);
					lpmul b_new = create_lpmul(plead/gcd(l2,plead),rn);
					for (int nr_2 = 1; nr_2 < n0; nr_2++)
					{
						lp rn2 = R[nr_2];
						if (b_new.smuled/rn2.s == 0)
						{
							nr_2++;
							continue;
						}
						if (gvw_less(rn2,b_new) != 0)
						{
							b_new.smuled = poly(0);
							break;
						}
s					}
					if (b_new.smuled != 0)
					{
						B = insert_in_sorted_list(B, b_new, "smul_less");
					}
				}
			}
			if (size(B) == 0) break;
			lpmul bs_premul = B[1];
			p = create_lp(bs_premul.smuled, bs_premul.p*(bs_premul.smuled/bs_premul.s));			
		}
		ideal result;
		for (int n0 = 1; n0 <= size(R); n0++)
		{
			lp rn = R[n0];
			if (rn.p != 0) {result = result + rn.p;}
		}
		I0 = result;
	}
	printf("ZERO REDUCTIONS: %s", zero_reductions);
	return(I0);
}

proc simple_test_ideal()
{

  ring R;

  ideal i=x*y+x,x*x,y;
  export(R);
  export(i);
}


//string basic_ideal="cyclicn(6)";
string basic_ideal="katsuran(9)";
//test_kgb(basic_ideal, "sba(i,0,1)");
test_kgb(basic_ideal, "sba(i,0,0)");
test_kgb(basic_ideal, "sba(i,1,0)");
test_kgb(basic_ideal, "ssg_sing(i)");
//test_kgb(basic_ideal, "sba(i,1,1)");
$
	