//
system("--min-time", "0.001");
system("--ticks-per-sec", 1000);
option(noredefine);
option(redSB);
LIB "benchs.lib";

string NL = "
";
proc test_kgb(string bench_call, string gb_call)
{
	string uniq_name = bench_call+"_by_"+gb_call;
	sprintf("--- "+uniq_name+"---");
	execute(bench_call)
	int ot0 = timer;
	execute("ideal f =" + gb_call);
	int ot1 = timer;
	ideal f_reduced = interred(f);
	int ot2 = timer;
	string info = 
		sprintf("Size of reduced basis:    %s    non-reduced:%s",size(f_reduced),size(f)) + NL +
		sprintf("Time:                     %s    %s", ot1-ot0, ot2-ot1);
	printf(info);
	link save = "ASCII:w res/" + uniq_name;
	write(save,f_reduced);
	printf("saved");
}

newstruct("lp","poly s, poly p");
newstruct("lpmul","lp","poly smuled");
proc gvw_less(lp p1, lp p2)
{
	poly l1 = leadmonom(p1.p)*p2.s;
	poly l2 = leadmonom(p2.p)*p1.s;
	return (l1<l2);
}
proc smul_less(lpmul p1, lpmul p2)
{
	poly l1 = p1.smuled;
	poly l2 = p2.smuled;
	return (l1<l2);
}

proc ssg_sing(ideal I)
{
	proc create_lp(poly s, poly p)
	{
		lp result;
		result.s = s;
		result.p = p;
		return(result);
	}
	proc create_lpmul(poly mul_by, lp sp)
	{
		lpmul result;
		result.smuled = sp.s*mul_by;
		result.s = sp.s;
		result.p = sp.p;
		return(result);
	}
	proc insert_in_sorted_list(list sorted_list, def new_elem, string comp_func)
	{
		int pos=0;
		while (pos < size(sorted_list))
		{
			execute("int compare_result="+comp_func+"(new_elem, sorted_list[pos+1])");
			if (compare_result) break;
			pos++;
		}
		return(insert(sorted_list, new_elem, pos));
	}
	proc divisible(poly mon1, poly mon2)
	{
		return (reduce(mon1, mon2) == 0)
	}
	proc norm_leadcoef(poly p)
	{
		return(simplify(p,1));
	}
	int zero_reductions = 0;
	ideal I0 = I[1];
	for (int n = 2; n <= size(I); n++)
	{
		I0 = interred(I0);
		lp p = create_lp(1,I[n]);
		list R;
		list B;
		for (int n0 = 1; n0 <= size(I0); n0++)
		{
			R = R + list(create_lp(0,norm_leadcoef(I0[n0])));
		}
		while(1)
		{
			//print("B = " + string(B));
			//print("R = " + string(R));
			int reduced_to_zero = 0;
			//print("processing " + string(p));
			while(1)
			{
				lp reductor;
				poly plead = leadmonom(p.p);
				poly div_result = 0;
				for (int n0 = size(R); n0 >=1 ; n0--)
				{
					lp rn = R[n0];
					if (gvw_less(p,rn) == 0) {break;}
					div_result = plead/leadmonom(rn.p);
					if (div_result!=0)
					{
						reductor = rn;
						break;
					}
				}	 	
				if (reductor.p == 0) {break;}
				p.p = norm_leadcoef(p.p-div_result*reductor.p);
				if (p.p == 0)
				{
					reduced_to_zero = 1;
					break;
				}
			}
			//print("inserting " + string(p));
			//print("reduced_to_zero = " + string(reduced_to_zero));
			R = insert_in_sorted_list(R, p, "gvw_less");
			if (reduced_to_zero == 0)
			{
				poly plead = leadmonom(p.p);
				for (int n0 = size(R); n0 >=1; n0--)
				{
					lp rn = R[n0];					
					if (gvw_less(p,rn) == 0) {break;}
					poly l2 = leadmonom(rn.p);
					B = insert_in_sorted_list(B, create_lpmul(l2/gcd(l2,plead),p), "smul_less");
				}
				for (int n0 = 1; n0 <= size(R); n0++)
				{
					lp rn = R[n0];
					if (gvw_less(rn,p) == 0) {break;}
					if (rn.p == 0) {n0++; continue;}
					poly l2 = leadmonom(rn.p);
					B = insert_in_sorted_list(B, create_lpmul(plead/gcd(l2,plead),rn), "smul_less");
				}
			}
			//print("B_prev = " + string(B));
			int nb = 1;
			while (nb <= size(B))
			{
				lpmul b = B[nb];
				for (int n0 = 1; n0 <= size(R); n0++)
				{
					lp rn = R[n0];					
					if (gvw_less(rn,b) == 0) {break;}
					if (divisible(b.smuled, rn.s))
					{
						B = delete(B, nb);						
						nb--;//Потом увеличится назад
						break;
					}
				}
				nb++;
			}
			if (size(B) == 0) break;
			lpmul bs_premul = B[1];
			p = create_lp(bs_premul.smuled, bs_premul.p*(bs_premul.smuled/bs_premul.s));			
		}
		ideal result;
		for (int n0 = 1; n0 <= size(R); n0++)
		{
			lp rn = R[n0];
			if (rn.p == 0){zero_reductions++;}
			else {result = result + rn.p;}
		}
		I0 = result;
	}
	printf("ZERO REDUCTIONS: %s", zero_reductions);
	return(I0);
}

proc simple_test_ideal()
{

  ring R;

  ideal i=x*y+x,x*x,y;
  export(R);
  export(i);
}


string basic_ideal="cyclicn(5)";
//string basic_ideal="simple_test_ideal()";
test_kgb(basic_ideal, "sba(i,0,1)");
test_kgb(basic_ideal, "sba(i,0,0)");
test_kgb(basic_ideal, "sba(i,1,0)");
test_kgb(basic_ideal, "ssg_sing(i)");
//test_kgb(basic_ideal, "sba(i,1,1)");
$
	